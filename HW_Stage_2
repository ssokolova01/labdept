### Task 2.1 ###
import pandas as pd
import scipy.stats as stats
import seaborn as sns

# Load the data
df = pd.read_csv('https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/main/Python/Dataset/seaborn_microbe.csv')

"""
    I try many times to load the dataset from github but still get the same error that the file doesn't exist,
    I do some research and turn out that it is not possible to load the dataset usimg directly the link path from github, so we have to change it a little bit
        by replacing the address of git to raw.githubusercontent.
    """

# Define a function to calculate the carrying capacity and time to reach it
def calculate_carrying_capacity(df):
    """
    This function calculates the carrying capacity and the time to reach it for each strain in the dataframe.
    The function from the next din't really work with this task since the columns are already established in the dataset so it is not necessary to create them.
        """

    carrying_capacities = []
    for strain in df['Strain'].unique():
        for condition in df['Condition'].unique():
            subset = df[(df['Strain'] == strain) & (df['Condition'] == condition)]
            max_od600 = subset['OD600'].max()
            time_to_max_od600 = subset.loc[subset['OD600'].idxmax(), 'Time']
            carrying_capacities.append(
                {
                    'Strain': strain,
                    'Condition': condition,
                    'Carrying Capacity': max_od600,
                    'Time to Carrying Capacity': time_to_max_od600,
                }
            )
    return pd.DataFrame(carrying_capacities)
    """Returns:
        pandas.DataFrame: A dataframe with the carrying capacity and time to reach it for each strain.
    """

# Calculate the carrying capacity and time to reach it for each strain
carrying_capacity_df = calculate_carrying_capacity(df)

# Convert 'Time to Carrying Capacity' to numeric
carrying_capacity_df['Time to Carrying Capacity'] = pd.to_numeric(
    carrying_capacity_df['Time to Carrying Capacity'], errors='coerce'
)

# Drop rows with N/A values
carrying_capacity_df = carrying_capacity_df.dropna(subset=['Time to Carrying Capacity'])
"""
I decide to drop the N/A value instead of replacimg them with zero
        It allow us to use a few data instead and the resolution is simplier.
    """

# Plot the growth curves using seaborn relational plot
for strain in df['Strain'].unique():
    g = sns.relplot(
        data=df[df['Strain'] == strain],
        x='Time',
        y='OD600',
        hue='Condition',
        kind='line',
    )
    g.fig.suptitle(f'Growth curve for {strain}')
    g.fig.subplots_adjust(top=0.9)  # Adjust title position
    g.refline(y=0)  # Add a horizontal line at y=0
    print(f"Growth Curve for {strain}:")
    print(g)

# statistical t-test
for strain in df['Strain'].unique():
    conditions = df['Condition'].unique()
    condition1 = carrying_capacity_df[
        (carrying_capacity_df['Strain'] == strain)
        & (carrying_capacity_df['Condition'] == conditions[0])
    ]['Time to Carrying Capacity']
    condition2 = carrying_capacity_df[
        (carrying_capacity_df['Strain'] == strain)
        & (carrying_capacity_df['Condition'] == conditions[1])
    ]['Time to Carrying Capacity']
    t_stat, p_val = stats.ttest_ind(condition1, condition2, equal_var=False)
    print(f'T-test results for {strain}:')
    print(f'T-statistic: {t_stat:.3f}')
    print(f'P-value: {p_val:.3f}')
    if p_val < 0.05:
        print('There is a significant difference between the two conditions.\n')
    else:
        print('There is no significant difference between the two conditions.\n')

# loop over each strain for scatter plots
for strain in df['Strain'].unique():
    g = sns.relplot(
        x='Condition',
        y='Time to Carrying Capacity',
        data=carrying_capacity_df[carrying_capacity_df['Strain'] == strain],
        kind='scatter',
    )
    g.fig.suptitle(f'Time to carrying capacity for {strain}')
    g.fig.subplots_adjust(top=0.9)
    print(f"Scatter Plot for {strain}:")
    print(g)

# loop over each strain for box plots using categories plot
for strain in df['Strain'].unique():
    g = sns.catplot(
        x='Condition',
        y='Time to Carrying Capacity',
        data=carrying_capacity_df[carrying_capacity_df['Strain'] == strain],
        kind='box',
    )
    g.fig.suptitle(f'Time to carrying capacity for {strain}')
    g.fig.subplots_adjust(top=0.9)
    print(f"Box Plot for {strain}:")
    print(g)

### Task 2.4 ###
#Import two datasets: SIFT and FoldX
data_source_sift = "https://raw.githubusercontent.com/HackBio-Internship/public_datasets/main/R/datasets/sift.tsv"
data_source_foldx = "https://raw.githubusercontent.com/HackBio-Internship/public_datasets/main/R/datasets/foldX.tsv"

#Read datasets' files and specify delimiter to separate values
df_sift = pd.read_csv(data_source_sift, sep = r'\s+')
df_foldx = pd.read_csv(data_source_foldx, sep = r'\s+')

#Create specific_Protein_aa column in both datasets
df_sift['specific_Protein_aa'] = df_sift['Protein'] + '_' + df_sift['Amino_Acid']
df_foldx['specific_Protein_aa'] = df_foldx['Protein'] + '_' + df_foldx['Amino_Acid']

#Merge of the SIFT and FoldX datasets in one dataframe using specific_Protein_aa column
final_df = pd.merge(df_sift, df_foldx, on='specific_Protein_aa', how='outer')

#New merged dataframe filtering by sift_Score (<0.05) and foldx_Score (>2)
filtered_df = final_df[(final_df['sift_Score'] < 0.05) & (final_df['foldX_Score'] > 2)]

#Checking if there are any differences between filtered results for data from SIFT and FoldX datasets.
#The result was True, so the filtering results for both data source coincide and we can continue to work with one of them.
same_values = (filtered_df['Amino_Acid_x'] == filtered_df['Amino_Acid_y']).all()
print(f"Are Amino_Acid_x and Amino_Acid_y identical? {same_values}")

#Extracting from Amino_Acid the first amino acid to explore which of them has the most functional and structural impact.
#Write it into new column Original_AA
filtered_df['Original_AA_x'] = filtered_df['Amino_Acid_x'].str[0]

#Count, index columns and form final frequency table of the amino acids.
amino_acid_freq_x = filtered_df['Original_AA_x'].value_counts().reset_index()
amino_acid_freq_x.columns = ['Amino_Acid', 'Frequency']

#Visualisation

#Bar plot
import seaborn as sns
sns.set_style("whitegrid")
bar_plot = sns.catplot(
  data=amino_acid_freq_x,
  x="Amino_Acid",
  y="Frequency",
  kind="bar",
  palette="magma",
  height=6,
  aspect=1.5
)
bar_plot.set_axis_labels("Amino Acid", "Total Frequency")
bar_plot.fig.suptitle("Amino Acid Frequency Distribution (Bar Plot)")

#Pie chart
import matplotlib.pyplot as plt
plt.figure(figsize=(8,8))
plt.pie(amino_acid_freq_x['Frequency'], labels=amino_acid_freq_x['Amino_Acid'],
    autopct='%1.1f%%', colors=sns.color_palette("magma", len(amino_acid_freq_x)),
    startangle=90, wedgeprops={'edgecolor': 'black'})
plt.title("Amino Acid Frequency Distribution (Pie Chart)", fontsize=14)
plt.show()

#Amino acid with the highest impact on protein structure and function: G (Glycine)
#Glycine's impact on protein structure and function:
#Slycine is the smallest AA which enables it to fold into a compact structure. That is used in collagen which can fold into a triple helix structure. Glycine provides flexibility for enzyme active sites.

#Find amino acids with Frequency more than 100 occurrence.
high_occurrence_aa = amino_acid_freq_x[amino_acid_freq_x['Frequency'] > 100]
print(high_occurrence_aa)

#Structural and functional properties of amino acids with more than 100 occurrences.
#AA with occurrences > 100 (13): G (Glycine), L (Leucine), A (Alanine), P (Proline), V (Valine), R (Arginine), I (Isoleucine), Y (Tyrosine), D (Aspattic acid), F (Phenylalanine), S (Serine), T (Threonine), W (Tryptophane). 
#Hydrophobic amino acids (L, A, P, V, I, F, W) stabilize the protein core. Polar and charged amino acids (R, Y, D, S, T) participate in catalysis, signaling, and interactions. Proline (P) and glycine (G) uniquely affect protein flexibility.
#G is small and flexible, it disrupts secondary structures so that it increases conformational flexibility. L, I, V, A are hydrophobic and they are essential for structural integrity. Proline is rigid and it disrupts helices, so that it forces bends in protein. R, D are charged and involved in salted bridges; they are key for enzimatic reactions and protein interactions. Y, W, F have aromatic structure which results into stacking of interactions; they are important for signaling and enzyme active sites. Serine and Threonine are polar which allow them to form hydrogen bonds; they are crucial for phosphorylation and regulation processes.
#Conclusion. Hydrophobic amino acids (L, A, P, V, I, F, W) stabilize the protein core. Polar and charged amino acids (R, Y, D, S, T) participate in catalysis, signaling, and interactions. Proline and glycine uniquely affect protein flexibility.
#Thus, AA with the highest occurrences are responsible for the protein structure stability (L, A) and flexibility (G). 


### Task 2.6 ###
